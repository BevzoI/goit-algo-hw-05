ВИКОРИСТАННЯ АЛГОРИТМІВ У БІБЛІОТЕКАХ МОВ ПРОГРАМУВАННЯ
Автори: Коваленко О.О., Корягіна Д.О.
ВНТУ – Вінницький національний технічний університет

Анотація
У статті розглядається використання алгоритмів у бібліотеках мов програмування. Проаналізовано найбільш поширені алгоритми пошуку та їх реалізації мовою Java. Підкреслено важливість розуміння принципів роботи алгоритмів для ефективного використання в реальних задачах.

Ключові слова: алгоритми, сортування, лінійний пошук, двійковий пошук, пошук стрибками, інтерполяційний пошук, експоненціальний пошук, жадібний алгоритм.

Вступ
З розвитком комп’ютерних наук сформувався певний набір алгоритмів та структур даних, які є основою для вирішення практичних завдань. Наприклад, алгоритми сортування широко використовуються в електронній комерції та системах рекомендацій, хеш-таблиці — для перевірки автентичності користувачів, графи — для побудови маршрутів і соціальних зв’язків.

Алгоритми — це чітко визначена послідовність дій, що веде до розв’язання поставленої задачі. Сучасні бібліотеки мов програмування вже містять безліч реалізованих алгоритмів, які значно спрощують роботу розробників. Однак знання принципів їхньої роботи залишається важливим.

Мета дослідження
Визначити найбільш популярні алгоритми в стандартних бібліотеках програмування та проаналізувати їх особливості, переваги й сфери застосування.

Використання алгоритмів у стандартних бібліотеках
Стандартна бібліотека мови програмування — це набір функцій, структур та алгоритмів, які доступні без додаткового підключення. Зазвичай вона містить:

алгоритми (сортування, пошук тощо);

структури даних (списки, дерева, хеш-таблиці);

функції введення/виведення та взаємодії з операційною системою.

Поширені алгоритми пошуку (на прикладі Java)
Лінійний пошук
Простий метод перебору, підходить для невеликих, несортованих наборів даних.

public static int linearSearch(int arr[], int elementToSearch) {
    for (int index = 0; index < arr.length; index++) {
        if (arr[index] == elementToSearch)
            return index;
    }
    return -1;
}
Двійковий пошук
Ефективний для відсортованих масивів. Ділить масив на половини та порівнює цільовий елемент із середнім.

public static int binarySearch(int arr[], int elementToSearch) {
    int firstIndex = 0, lastIndex = arr.length - 1;
    while(firstIndex <= lastIndex) {
        int middleIndex = (firstIndex + lastIndex) / 2;
        if (arr[middleIndex] == elementToSearch)
            return middleIndex;
        else if (arr[middleIndex] < elementToSearch)
            firstIndex = middleIndex + 1;
        else
            lastIndex = middleIndex - 1;
    }
    return -1;
}
Пошук стрибками (Jump Search)
Працює на відсортованих масивах, виконує стрибки з кроком √n.

public static int jumpSearch(int[] arr, int elementToSearch) {
    int length = arr.length;
    int step = (int)Math.sqrt(length);
    int prev = 0;

    while (arr[Math.min(step, length) - 1] < elementToSearch) {
        prev = step;
        step += (int)Math.sqrt(length);
        if (prev >= length) return -1;
    }

    while (arr[prev] < elementToSearch) {
        prev++;
        if (prev == Math.min(step, length)) return -1;
    }

    if (arr[prev] == elementToSearch) return prev;
    return -1;
}
Інтерполяційний пошук
Оптимальний для рівномірно розподілених даних.

public static int interpolationSearch(int[] arr, int x) {
    int low = 0, high = arr.length - 1;
    while (low <= high && x >= arr[low] && x <= arr[high]) {
        int pos = low + ((x - arr[low]) * (high - low)) / 
                  (arr[high] - arr[low]);

        if (arr[pos] == x) return pos;
        if (arr[pos] < x) low = pos + 1;
        else high = pos - 1;
    }
    return -1;
}
Експоненціальний пошук
Працює шляхом експоненційного розширення меж, після чого застосовується двійковий пошук.

public static int exponentialSearch(int[] arr, int x) {
    if (arr[0] == x) return 0;
    int i = 1;
    while (i < arr.length && arr[i] <= x)
        i *= 2;
    return Arrays.binarySearch(arr, i / 2, Math.min(i, arr.length), x);
}
Жадібні алгоритми
Жадібний алгоритм на кожному кроці обирає найкращий локальний варіант, сподіваючись, що це призведе до глобального оптимального результату. Хоча це не завжди гарантує точне рішення, у багатьох задачах такий підхід працює ефективно.

Приклад: мінімізація кількості монет
Потрібно видати 98 копійок монетами номіналом 1, 2, 5, 10 і 25.
Жадібний підхід:

3 монети по 25 → 75 коп.

2 монети по 10 → 20 коп.

1 монета по 2 → 2 коп.

1 монета по 1 → 1 коп.
Разом: 7 монет

Висновки
Розуміння принципів роботи алгоритмів дає розробнику перевагу у виборі найефективнішого рішення для конкретної задачі. Навіть маючи доступ до готових реалізацій, необхідно знати, як і коли їх застосовувати. Адже програмування — це не просто написання коду, а вміння вирішувати проблеми.